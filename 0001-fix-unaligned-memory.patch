From 145acd646fbb289f3338f733a45a8a42c2a28fac Mon Sep 17 00:00:00 2001
From: Myriad-Dreamin <camiyoru@gmail.com>
Date: Fri, 2 Jun 2023 11:33:26 +0800
Subject: [PATCH] fix: unaligned memory

---
 core/src/artifact_ir/core.rs | 11 ++++++++++-
 core/src/artifact_ir/mod.rs  | 28 +++++++++++++++++++++++-----
 2 files changed, 33 insertions(+), 6 deletions(-)

diff --git a/core/src/artifact_ir/core.rs b/core/src/artifact_ir/core.rs
index eae1510..380c2a4 100644
--- a/core/src/artifact_ir/core.rs
+++ b/core/src/artifact_ir/core.rs
@@ -19,6 +19,14 @@ pub type PaintRef = i32;
 pub type Lang = String;
 pub type EcoString = String;
 
+// this is not exact the item aligen, but a constant for the all possible items on all platforms.
+pub(super) const fn item_align_up(x: usize) -> usize {
+    const ALIGN: usize = 8;
+    const MASK: usize = !(ALIGN - 1);
+
+    (x + ALIGN - 1) & MASK
+}
+
 /// Stably identifies an element in the document across multiple layout passes.
 ///
 /// This struct is created by [`StabilityProvider::locate`].
@@ -172,7 +180,8 @@ impl<'a, T> Iterator for ItemArrayIter<'a, T> {
 
     fn next(&mut self) -> Option<Self::Item> {
         if self.index < self.array.size {
-            let off = self.array.start as usize + self.index as usize * std::mem::size_of::<T>();
+            let off = self.array.start as usize
+                + self.index as usize * item_align_up(std::mem::size_of::<T>());
             let item = unsafe { &*(self.buffer.as_ptr().add(off) as *const T) };
             self.index += 1;
             Some(item)
diff --git a/core/src/artifact_ir/mod.rs b/core/src/artifact_ir/mod.rs
index 95099ae..336e21f 100644
--- a/core/src/artifact_ir/mod.rs
+++ b/core/src/artifact_ir/mod.rs
@@ -85,7 +85,8 @@ impl ArtifactBuilder {
     }
 
     pub fn push_item<T: Sized + HasItemRefKind>(&mut self, item: &T) -> ItemRef<T> {
-        let idx = self.buffer.len();
+        let idx = item_align_up(self.buffer.len());
+        self.buffer.resize(idx, 0);
         unsafe {
             let raw_item =
                 slice::from_raw_parts(item as *const T as *const u8, std::mem::size_of::<T>());
@@ -776,6 +777,7 @@ impl Artifact {
 
 #[cfg(test)]
 mod tests {
+
     use crate::artifact_ir::*;
 
     fn build_simple_refs(builder: &mut ArtifactBuilder) -> ItemArray<FrameItem> {
@@ -823,11 +825,26 @@ mod tests {
         let refs = build_simple_refs(&mut builder);
         assert_eq!(refs.len(), 2);
 
-        let mut it = refs.iter(&builder.buffer);
+        // todo: provide api to make such a bufffer
+        let mut view_buffer: Vec<u8> = Vec::with_capacity(builder.buffer.len() + 16);
+        let align_view = unsafe {
+            let ptr = view_buffer.as_mut_ptr() as *mut u8;
+            let cap = view_buffer.capacity();
+
+            let align = ptr.align_offset(8);
+            let ptr = ptr.add(align);
+            let cap = cap - align;
+            std::slice::from_raw_parts_mut(ptr, cap)
+        };
+        assert!(align_view.len() >= builder.buffer.len());
+        align_view[0..builder.buffer.len()].copy_from_slice(builder.buffer.as_slice());
+        let align_view = &align_view[..builder.buffer.len()];
+
+        let mut it = refs.iter(align_view);
         assert_eq!(it.len(), 2);
         if let Some(FrameItem::Text(x)) = it.next() {
             assert_eq!(x.glyphs.len(), 1);
-            if let Some(x) = x.glyphs.iter(&builder.buffer).next() {
+            if let Some(x) = x.glyphs.iter(align_view).next() {
                 assert_eq!(x.range_start, 0);
             } else {
                 panic!("Expected glyph item");
@@ -836,7 +853,8 @@ mod tests {
             panic!("Expected text item");
         }
 
-        if let Some(FrameItem::Shape(x)) = it.next() {
+        let item = it.next();
+        if let Some(FrameItem::Shape(x)) = item {
             assert_eq!(
                 x.geometry,
                 Geometry::Rect(Size {
@@ -845,7 +863,7 @@ mod tests {
                 })
             );
         } else {
-            panic!("Expected shape item");
+            panic!("Expected shape item, got {item:?}");
         }
 
         assert_eq!(it.next(), None);
-- 
2.40.1.windows.1

